#include <iostream>
#include <cstring>
using namespace std;

/*
 * 因为只需要一半的代价，合并最后两堆石子时存在一个分界线，使结果最小
 * 当结果确定时总代价=(1到x的总代价)+(x+1到n的总代价)
 * 不知道分界线时直接暴力枚举，由此可得递推方程
 * 将一个大问题划分为最基本的小问题（DP的思维方式）
 * 递归时每次都取最小值
 * 递归很慢，一个相同的区间会被计算很多次
 * 时间复杂度：O(n^2)个区间，每次计算枚举分界线m，分界线最多约等于n，所以总复杂度是O(n^3)
 * 记忆化搜索！
 * 在递归的过程中记录每次运算的值，如果已经被计算过就直接使用
 *
 * 以动态规划的思路分析：
 * 1.最优子结构：为了计算区间[i,j]的最小代价，需要先计算所有满足i<k<j上的区间[i,k]和[k+1,j]的最小代价
 * 2.无后效性：只关心[i,j]的最小代价，不关心具体是怎么合并的
 * 状态：用f[i][j]表示区间[i,j]的最小代价
 * 转移：f[i][j]=min(f[i][k]+f[k+1][j])+(i到j的和);
 * 只要按照j-i的长度由小到大排序就可得出结果
 * */

const int N = 1010;
int s[N], f[N][N];

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> s[i];
    memset(&f, 127, sizeof f);

    for (int i = 1; i <= n; i++) s[i] += s[i - 1];
    for (int i = 1; i <= n; i++) f[i][i] = 0;// 初始化当只有这一堆石子时无法被划分，返回0

    for (int i = 1; i <= n; i++)// 长度
        for (int j = 1; j <= n - i; j++)// 左端点j，右端点j+i
            for (int k = j; k < j + i; k++)// 分界点
                f[j][j + i] = min(f[j][j + i], f[j][k] + f[k + 1][j + i] + s[j + i] - s[j - 1]);
    cout << f[1][n] << endl;
    return 0;
}