#include <bits/stdc++.h>
using namespace std;

/*
 * Floyd
 * 多源最短路，可以求得任意两点间的最短路
 * 时间复杂度O(n^3)
 *
 * 核心思想：动态规划
 * 定义三维数组 f[k][x][y]
 * f[k][x][y] 为考虑前k个点时x到y的最短路 （从x经过k到y是否会使距离缩短）
 * f[k][x][y]=min(f[k-1][x][y],f[k-1][x][k]+f[k-1][k][y]);
 *  f[k-1][x][y] 表示前一次的路径（也就是不包括k的情况）
 *  f[k-1][x][k]+f[k-1][k][y] 表示加入k后的路径（也就是经过k的情况）
 * 只会出现取与不取的情况，所以直接从这两个情况下取最佳结果即可（较小值）
 * 两点间的可达性：如果x到k或者k到y存在一条路不可达的情况，就会超过INF，所以小于INF的距离一定是可达的
 *
 * 其中k这一维是可以省略的，并不会参与最短路计算，单纯用于计数
 *
 * 模拟,f[][]=
 *  0 1 - 1
 *  1 0 1 -
 *  - 1 0 1
 *  1 - 1 0
 * 其中1->3就可以由1->2加上2->3得到，距离为1+1=2
 * f[][]更新为
 *  0 1 2 1
 *  1 0 1 -
 *  2 1 0 1
 *  1 - 1 0
 *
 * 思考：
 *  想让两点间的距离变短，只有两个点的话是一定做不到的，需要引入第三个点，如果这第三个点到左边和右边的距离和小于原长
 *  那么就可以通过加入这个点使两个点的距离缩短，再用这个缩短的距离引入第三个点，也就表示中间插入两个点的情况，以此类推
 *  通过暴力尝试在起点和终点间加入每个点（如果其他点也是最小的话），就可以得到这两点的最小距离
 *  那么需要计算图中每个点的最小距离，那么就需要在每一组起点终点间尝试插入一个点，更新最小值
 *  并用这个最小值得到的结果后，再插入其他点，使其他点也一起更新最小值，只要保证每次插入都保证最小，那么也就可以使最后的结果最小
 * */

const int N = 110;
int f[N][N];

int main() {
#ifdef __LOCAL__
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
#endif

    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    int n, m;
    cin >> n >> m;
    memset(&f, 0x3f, sizeof f);// 初始化，0x3f避免溢出
    for (int i = 0; i < m; i++)
    {
        int x, y, z;
        cin >> x >> y >> z;
        if (x < y) swap(x, y);// 这行就没有任何用处了
        f[x][y] = min(f[x][y], z);// 下面那部分，不然只有一半的图像
        f[y][x] = min(f[y][x], z);// 上面那部分
    }
    for (int i = 0; i <= n; i++) f[i][i] = 0;// 对角线就是到自己的长度，一定是0

    // Floyd
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                f[i][j] = min(f[i][j], f[i][k] + f[k][j]);

    // 输出
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++)
            cout << f[i][j] << ' ';
        cout << '\n';
    }
    return 0;
}


// https://www.luogu.com.cn/problem/B3647